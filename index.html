<html>
  <head>
    <meta charset='utf-8'>
    <title>自由帳</title>
  </head>
  <body>
    <br>
==[details]=========================================================<br>
    <br>
    vector<int> vals                  : ソートする配列 <br>
    struct quick_data                 : 1つの並び替え作業についての内容を格納する構造体。参照する部分の始点・終点(要素の位置)start・endと、基準となる数値pivot<br>
                                        (ここでは扱いやすいように終点のendに1を足したend_plus1を利用している)<br>
    vector<vector<quick_data>> qdatas : 作業の履歴・次に行う作業の内容を管理する為の配列。<br>
    <br>
    通常のQuick_sortは再帰関数を利用して一気に片付けるが、ここではアニメーションを作成するために、一度の作業の終了後に次の作業の内容をqdatasにメモしてから(次の入力まで)待機させる。<br>
    <br>
    作業を始めるor再開するときに、QS::funcを呼び出し、qdatas[これまでの作業回数+1]に格納された作業をQS::quick_sortで行う。<br>
    <br>
    (datasなんて、配列名が若干おかしい気もするが...手遅れ♥)<br>
    <br>
==[source]=========================================================<br>

struct quick_data{<br>
<emsp>int start,end_plus1,pivot;<br>
<emsp>quick_data(int _start, int _end_plus1, int _pivot=-1){<br>
<emsp><emsp>start=_start;<br>
<emsp><emsp>end_plus1=_end_plus1;<br>
<emsp><emsp>pivot=_pivot;<br>
<emsp>}<br>
};<br>
<emsp><br>
<emsp><br>
void QS::quick_sort(quick_data _data){<br>
<br>
<emsp>if(_data.pivot==-1)_data.pivot=_data.end_plus1-1;<br>
<br>
<emsp>int right=_data.end_plus1-1,left=_data.start;<br>
<emsp>bool retry=true;<br>
  <br>  
<emsp>//出力用<br>
<emsp>//cout<<_data.start<<":"<<_data.end_plus1<<"("<<vals[_data.pivot]<<endl;<br>
<br>
<emsp>while(right>left){
<emsp><emsp>bool right_is_ready=false;<br>
<br>
<emsp><emsp>if(vals[right]<=vals[_data.pivot]){<br>
<emsp><emsp><emsp>right_is_ready=true;<br>
<emsp><emsp>}<br>
<emsp><emsp>else right--;<br>
<br>
<emsp><emsp>if(vals[left]>=vals[_data.pivot]){<br>
<emsp><emsp><emsp>if(right_is_ready){<br>
<emsp><emsp><emsp><emsp>swap(vals[right],vals[left]);<br>
<emsp><emsp><emsp><emsp>retry=false;<br>
<emsp><emsp><emsp>}<br>
<emsp><emsp>}<br>
<emsp><emsp>else left++;<br>
<emsp>}<br>
<br>
<emsp>if(retry){<br>
<emsp><emsp>if(_data.pivot>_data.start)quick_sort(quick_data(_data.start,_data.end_plus1,_data.pivot-1));<br>
<emsp>}<br>
<emsp>else{<br>
<emsp><emsp>if(left-_data.start>=2)<emsp>qdatas[reps+1].push_back( quick_data(_data.start, left) );<br>
<emsp><emsp>if(_data.end_plus1-left>=2)qdatas[reps+1].push_back( quick_data(left, _data.end_plus1) );<br>
<emsp>}<br>
<emsp><br>
<br>
}<br>
<emsp><br>
void QS::func(){<br>
<emsp>qdatas.push_back({});<br>
<emsp>for(auto it:qdatas[reps]){<br>
<emsp><emsp>quick_sort(it);<br>
<emsp>}<br>
<emsp>reps++;<br>
}<br>
<br>
=========================================================<br>
    
  </body>
</html>
