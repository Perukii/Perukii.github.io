<html>
  <head>
    <meta charset='utf-8'>
    <title>タイトル</title>
  </head>
  <body>
    
==[details]=========================================================
    
    vector<int> vals                  : ソートする配列
    struct quick_data                 : 1つの並び替え作業についての内容を格納する構造体。参照する部分の始点・終点(要素の位置)start・endと、基準となる数値pivot
                                        (ここでは扱いやすいように終点のendに1を足したend_plus1を利用している)
    vector<vector<quick_data>> qdatas : 作業の履歴・次に行う作業の内容を管理する為の配列。
    
    通常のQuick_sortは再帰関数を利用して一気に片付けるが、ここではアニメーションを作成するために、一度の作業の終了後に次の作業の内容をqdatasにメモしてから(次の入力まで)待機させる。
    
    作業を始めるor再開するときに、QS::funcを呼び出し、qdatas[これまでの作業回数+1]に格納された作業をQS::quick_sortで行う。
    
    (datasなんて、配列名が若干おかしい気もするが...手遅れ♥)
    
==[source]=========================================================
    
struct quick_data{
    int start,end_plus1,pivot;
    quick_data(int _start, int _end_plus1, int _pivot=-1){
         start=_start;
         end_plus1=_end_plus1;
         pivot=_pivot;
    }
};
    
    
void QS::quick_sort(quick_data _data){

     if(_data.pivot==-1)_data.pivot=_data.end_plus1-1;

     int right=_data.end_plus1-1,left=_data.start;
     bool retry=true;
    
     //出力用
     //cout<<_data.start<<":"<<_data.end_plus1<<"("<<vals[_data.pivot]<<endl;

     while(right>left){
          bool right_is_ready=false;

          if(vals[right]<=vals[_data.pivot]){
               right_is_ready=true;
          }
          else right--;

          if(vals[left]>=vals[_data.pivot]){
               if(right_is_ready){
                    swap(vals[right],vals[left]);
                    retry=false;
               }
          }
          else left++;
     }

     if(retry){
          if(_data.pivot>_data.start)quick_sort(quick_data(_data.start,_data.end_plus1,_data.pivot-1));
     }
     else{
          if(left-_data.start>=2)    qdatas[reps+1].push_back( quick_data(_data.start, left) );
          if(_data.end_plus1-left>=2)qdatas[reps+1].push_back( quick_data(left, _data.end_plus1) );
     }
     

}
    
void QS::func(){
     qdatas.push_back({});
     for(auto it:qdatas[reps]){
          quick_sort(it);
     }
     reps++;
}
    
    
=========================================================
    
  </body>
</html>
